<?php
/**
 * LocationDTO
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  BeLenka\Deposco
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Deposco API
 *
 * Welcome to the Deposco API Reference! The Deposco API enables you to integrate your system with Deposco.  * Integrate a product information system (PIM) by creating and retrieving data for items, packs, UPCs, and kits. * Set up warehouse data by creating facilities, zones, locations, and storage details. * Create inbound orders that can be received and outbound orders that can be fulfilled with Deposco warehouse management processes.  This reference provides details on available operations, endpoints, parameters, schemas, and responses.  Example requests and responses are also available for you to use as a reference. You can copy the examples to use as a starting point for your own requests.  Review the guides to learn how the API is used in common business scenarios such as setting up the warehouse and integrating a Product Information Management (PIM) system.  When you're ready to get started, register for a developer account and then log in to create your application in the developer portal.
 *
 * The version of the OpenAPI document: 2.0.2519
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BeLenka\Deposco\Model;

use \ArrayAccess;
use \BeLenka\Deposco\ObjectSerializer;

/**
 * LocationDTO Class Doc Comment
 *
 * @category Class
 * @description Specific area in a facility where stock can be tracked.
 * @package  BeLenka\Deposco
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class LocationDTO implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'LocationDTO';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'self' => '\BeLenka\Deposco\Model\EntityRef',
        'business_unit' => '\BeLenka\Deposco\Model\EntityRef',
        'facility' => '\BeLenka\Deposco\Model\EntityRef',
        'zones' => '\BeLenka\Deposco\Model\PaginatedEntityReference',
        'number' => 'string',
        'locator' => 'string',
        'name' => 'string',
        'description' => 'string',
        'type' => 'string',
        'storage_type' => 'string',
        'status' => 'string',
        'dimensions' => '\BeLenka\Deposco\Model\Dimension',
        'pickable' => 'bool',
        'reserved' => 'bool',
        'lpn_controlled' => 'bool',
        'mixed_item_threshold' => 'string',
        'cycle_count' => 'bool',
        'cycle_count_frequency' => 'int',
        'last_counted_date' => '\DateTime',
        'pick_sequence' => 'int',
        'putaway_sequence' => 'int',
        'use_for_kit' => 'bool',
        'allocated_to_business_unit' => '\BeLenka\Deposco\Model\NullableEntityRef',
        'custom_attribute1' => 'string',
        'custom_attribute2' => 'string',
        'custom_attribute3' => 'string',
        'storage_details' => '\BeLenka\Deposco\Model\StorageCollectionDTO',
        'created_date' => '\DateTime',
        'updated_date' => '\DateTime',
        'created_by' => '\BeLenka\Deposco\Model\EntityRef',
        'updated_by' => '\BeLenka\Deposco\Model\EntityRef'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'self' => null,
        'business_unit' => null,
        'facility' => null,
        'zones' => null,
        'number' => null,
        'locator' => null,
        'name' => null,
        'description' => null,
        'type' => null,
        'storage_type' => null,
        'status' => null,
        'dimensions' => null,
        'pickable' => null,
        'reserved' => null,
        'lpn_controlled' => null,
        'mixed_item_threshold' => null,
        'cycle_count' => null,
        'cycle_count_frequency' => null,
        'last_counted_date' => 'date-time',
        'pick_sequence' => null,
        'putaway_sequence' => null,
        'use_for_kit' => null,
        'allocated_to_business_unit' => null,
        'custom_attribute1' => null,
        'custom_attribute2' => null,
        'custom_attribute3' => null,
        'storage_details' => null,
        'created_date' => 'date-time',
        'updated_date' => 'date-time',
        'created_by' => null,
        'updated_by' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'self' => false,
        'business_unit' => false,
        'facility' => false,
        'zones' => true,
        'number' => true,
        'locator' => false,
        'name' => true,
        'description' => true,
        'type' => true,
        'storage_type' => true,
        'status' => true,
        'dimensions' => false,
        'pickable' => false,
        'reserved' => false,
        'lpn_controlled' => false,
        'mixed_item_threshold' => true,
        'cycle_count' => false,
        'cycle_count_frequency' => false,
        'last_counted_date' => true,
        'pick_sequence' => false,
        'putaway_sequence' => false,
        'use_for_kit' => false,
        'allocated_to_business_unit' => true,
        'custom_attribute1' => true,
        'custom_attribute2' => true,
        'custom_attribute3' => true,
        'storage_details' => false,
        'created_date' => false,
        'updated_date' => false,
        'created_by' => false,
        'updated_by' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'self' => 'self',
        'business_unit' => 'businessUnit',
        'facility' => 'facility',
        'zones' => 'zones',
        'number' => 'number',
        'locator' => 'locator',
        'name' => 'name',
        'description' => 'description',
        'type' => 'type',
        'storage_type' => 'storageType',
        'status' => 'status',
        'dimensions' => 'dimensions',
        'pickable' => 'pickable',
        'reserved' => 'reserved',
        'lpn_controlled' => 'lpnControlled',
        'mixed_item_threshold' => 'mixedItemThreshold',
        'cycle_count' => 'cycleCount',
        'cycle_count_frequency' => 'cycleCountFrequency',
        'last_counted_date' => 'lastCountedDate',
        'pick_sequence' => 'pickSequence',
        'putaway_sequence' => 'putawaySequence',
        'use_for_kit' => 'useForKit',
        'allocated_to_business_unit' => 'allocatedToBusinessUnit',
        'custom_attribute1' => 'customAttribute1',
        'custom_attribute2' => 'customAttribute2',
        'custom_attribute3' => 'customAttribute3',
        'storage_details' => 'storageDetails',
        'created_date' => 'createdDate',
        'updated_date' => 'updatedDate',
        'created_by' => 'createdBy',
        'updated_by' => 'updatedBy'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'self' => 'setSelf',
        'business_unit' => 'setBusinessUnit',
        'facility' => 'setFacility',
        'zones' => 'setZones',
        'number' => 'setNumber',
        'locator' => 'setLocator',
        'name' => 'setName',
        'description' => 'setDescription',
        'type' => 'setType',
        'storage_type' => 'setStorageType',
        'status' => 'setStatus',
        'dimensions' => 'setDimensions',
        'pickable' => 'setPickable',
        'reserved' => 'setReserved',
        'lpn_controlled' => 'setLpnControlled',
        'mixed_item_threshold' => 'setMixedItemThreshold',
        'cycle_count' => 'setCycleCount',
        'cycle_count_frequency' => 'setCycleCountFrequency',
        'last_counted_date' => 'setLastCountedDate',
        'pick_sequence' => 'setPickSequence',
        'putaway_sequence' => 'setPutawaySequence',
        'use_for_kit' => 'setUseForKit',
        'allocated_to_business_unit' => 'setAllocatedToBusinessUnit',
        'custom_attribute1' => 'setCustomAttribute1',
        'custom_attribute2' => 'setCustomAttribute2',
        'custom_attribute3' => 'setCustomAttribute3',
        'storage_details' => 'setStorageDetails',
        'created_date' => 'setCreatedDate',
        'updated_date' => 'setUpdatedDate',
        'created_by' => 'setCreatedBy',
        'updated_by' => 'setUpdatedBy'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'self' => 'getSelf',
        'business_unit' => 'getBusinessUnit',
        'facility' => 'getFacility',
        'zones' => 'getZones',
        'number' => 'getNumber',
        'locator' => 'getLocator',
        'name' => 'getName',
        'description' => 'getDescription',
        'type' => 'getType',
        'storage_type' => 'getStorageType',
        'status' => 'getStatus',
        'dimensions' => 'getDimensions',
        'pickable' => 'getPickable',
        'reserved' => 'getReserved',
        'lpn_controlled' => 'getLpnControlled',
        'mixed_item_threshold' => 'getMixedItemThreshold',
        'cycle_count' => 'getCycleCount',
        'cycle_count_frequency' => 'getCycleCountFrequency',
        'last_counted_date' => 'getLastCountedDate',
        'pick_sequence' => 'getPickSequence',
        'putaway_sequence' => 'getPutawaySequence',
        'use_for_kit' => 'getUseForKit',
        'allocated_to_business_unit' => 'getAllocatedToBusinessUnit',
        'custom_attribute1' => 'getCustomAttribute1',
        'custom_attribute2' => 'getCustomAttribute2',
        'custom_attribute3' => 'getCustomAttribute3',
        'storage_details' => 'getStorageDetails',
        'created_date' => 'getCreatedDate',
        'updated_date' => 'getUpdatedDate',
        'created_by' => 'getCreatedBy',
        'updated_by' => 'getUpdatedBy'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_BULK_PICKING = 'Bulk Picking';
    public const TYPE_DAMAGED = 'Damaged';
    public const TYPE_PERMANENT = 'Permanent';
    public const TYPE_RACK_PICKING = 'Rack Picking';
    public const TYPE_RECONCILE = 'Reconcile';
    public const TYPE_REJECTED_RETURN_GOODS = 'Rejected Return Goods';
    public const TYPE_STAGING = 'Staging';
    public const TYPE_STATION = 'Station';
    public const TYPE_TEMPORARY = 'Temporary';
    public const TYPE_TRANSIENT = 'Transient';
    public const TYPE_VALUE_ADDED_SERVICE = 'Value Added Service';
    public const STORAGE_TYPE_DAMAGED = 'Damaged';
    public const STORAGE_TYPE_FULL_CASE_PICKING = 'Full Case Picking';
    public const STORAGE_TYPE_HAZMAT = 'Hazmat';
    public const STORAGE_TYPE_INSPECTION = 'Inspection';
    public const STORAGE_TYPE_MIXED_BIN = 'Mixed Bin';
    public const STORAGE_TYPE_PUTWALL_SLOT = 'Putwall Slot';
    public const STORAGE_TYPE_PUTWALL_STAGING = 'Putwall Staging';
    public const STORAGE_TYPE_QUARANTINE = 'Quarantine';
    public const STORAGE_TYPE_RECEIVING = 'Receiving';
    public const STORAGE_TYPE_RESERVE_STORAGE = 'Reserve Storage';
    public const STORAGE_TYPE_RETURNED = 'Returned';
    public const STORAGE_TYPE_SHIPPING = 'Shipping';
    public const STORAGE_TYPE_SPLIT_CASE_PICKING = 'Split Case Picking';
    public const STORAGE_TYPE_STAGING = 'Staging';
    public const STATUS_CYCLE_COUNT = 'Cycle Count';
    public const STATUS_MISCOUNT = 'Miscount';
    public const STATUS_ON_HOLD = 'On Hold';
    public const STATUS_READY = 'Ready';
    public const MIXED_ITEM_THRESHOLD_SINGLE_ITEM = 'Single Item';
    public const MIXED_ITEM_THRESHOLD_MULTI_ITEM = 'Multi Item';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_BULK_PICKING,
            self::TYPE_DAMAGED,
            self::TYPE_PERMANENT,
            self::TYPE_RACK_PICKING,
            self::TYPE_RECONCILE,
            self::TYPE_REJECTED_RETURN_GOODS,
            self::TYPE_STAGING,
            self::TYPE_STATION,
            self::TYPE_TEMPORARY,
            self::TYPE_TRANSIENT,
            self::TYPE_VALUE_ADDED_SERVICE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStorageTypeAllowableValues()
    {
        return [
            self::STORAGE_TYPE_DAMAGED,
            self::STORAGE_TYPE_FULL_CASE_PICKING,
            self::STORAGE_TYPE_HAZMAT,
            self::STORAGE_TYPE_INSPECTION,
            self::STORAGE_TYPE_MIXED_BIN,
            self::STORAGE_TYPE_PUTWALL_SLOT,
            self::STORAGE_TYPE_PUTWALL_STAGING,
            self::STORAGE_TYPE_QUARANTINE,
            self::STORAGE_TYPE_RECEIVING,
            self::STORAGE_TYPE_RESERVE_STORAGE,
            self::STORAGE_TYPE_RETURNED,
            self::STORAGE_TYPE_SHIPPING,
            self::STORAGE_TYPE_SPLIT_CASE_PICKING,
            self::STORAGE_TYPE_STAGING,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_CYCLE_COUNT,
            self::STATUS_MISCOUNT,
            self::STATUS_ON_HOLD,
            self::STATUS_READY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMixedItemThresholdAllowableValues()
    {
        return [
            self::MIXED_ITEM_THRESHOLD_SINGLE_ITEM,
            self::MIXED_ITEM_THRESHOLD_MULTI_ITEM,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('self', $data ?? [], null);
        $this->setIfExists('business_unit', $data ?? [], null);
        $this->setIfExists('facility', $data ?? [], null);
        $this->setIfExists('zones', $data ?? [], null);
        $this->setIfExists('number', $data ?? [], null);
        $this->setIfExists('locator', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('storage_type', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('dimensions', $data ?? [], null);
        $this->setIfExists('pickable', $data ?? [], null);
        $this->setIfExists('reserved', $data ?? [], null);
        $this->setIfExists('lpn_controlled', $data ?? [], null);
        $this->setIfExists('mixed_item_threshold', $data ?? [], null);
        $this->setIfExists('cycle_count', $data ?? [], null);
        $this->setIfExists('cycle_count_frequency', $data ?? [], null);
        $this->setIfExists('last_counted_date', $data ?? [], null);
        $this->setIfExists('pick_sequence', $data ?? [], null);
        $this->setIfExists('putaway_sequence', $data ?? [], null);
        $this->setIfExists('use_for_kit', $data ?? [], null);
        $this->setIfExists('allocated_to_business_unit', $data ?? [], null);
        $this->setIfExists('custom_attribute1', $data ?? [], null);
        $this->setIfExists('custom_attribute2', $data ?? [], null);
        $this->setIfExists('custom_attribute3', $data ?? [], null);
        $this->setIfExists('storage_details', $data ?? [], null);
        $this->setIfExists('created_date', $data ?? [], null);
        $this->setIfExists('updated_date', $data ?? [], null);
        $this->setIfExists('created_by', $data ?? [], null);
        $this->setIfExists('updated_by', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['business_unit'] === null) {
            $invalidProperties[] = "'business_unit' can't be null";
        }
        if ($this->container['facility'] === null) {
            $invalidProperties[] = "'facility' can't be null";
        }
        if (!is_null($this->container['number']) && (mb_strlen($this->container['number']) > 150)) {
            $invalidProperties[] = "invalid value for 'number', the character length must be smaller than or equal to 150.";
        }

        if ($this->container['locator'] === null) {
            $invalidProperties[] = "'locator' can't be null";
        }
        if ((mb_strlen($this->container['locator']) > 150)) {
            $invalidProperties[] = "invalid value for 'locator', the character length must be smaller than or equal to 150.";
        }

        if (!preg_match("/.*\\S.*/", $this->container['locator'])) {
            $invalidProperties[] = "invalid value for 'locator', must be conform to the pattern /.*\\S.*/.";
        }

        if (!is_null($this->container['name']) && (mb_strlen($this->container['name']) > 50)) {
            $invalidProperties[] = "invalid value for 'name', the character length must be smaller than or equal to 50.";
        }

        if (!is_null($this->container['description']) && (mb_strlen($this->container['description']) > 50)) {
            $invalidProperties[] = "invalid value for 'description', the character length must be smaller than or equal to 50.";
        }

        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStorageTypeAllowableValues();
        if (!is_null($this->container['storage_type']) && !in_array($this->container['storage_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'storage_type', must be one of '%s'",
                $this->container['storage_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getMixedItemThresholdAllowableValues();
        if (!is_null($this->container['mixed_item_threshold']) && !in_array($this->container['mixed_item_threshold'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'mixed_item_threshold', must be one of '%s'",
                $this->container['mixed_item_threshold'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['custom_attribute1']) && (mb_strlen($this->container['custom_attribute1']) > 50)) {
            $invalidProperties[] = "invalid value for 'custom_attribute1', the character length must be smaller than or equal to 50.";
        }

        if (!is_null($this->container['custom_attribute2']) && (mb_strlen($this->container['custom_attribute2']) > 50)) {
            $invalidProperties[] = "invalid value for 'custom_attribute2', the character length must be smaller than or equal to 50.";
        }

        if (!is_null($this->container['custom_attribute3']) && (mb_strlen($this->container['custom_attribute3']) > 50)) {
            $invalidProperties[] = "invalid value for 'custom_attribute3', the character length must be smaller than or equal to 50.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets self
     *
     * @return \BeLenka\Deposco\Model\EntityRef|null
     */
    public function getSelf()
    {
        return $this->container['self'];
    }

    /**
     * Sets self
     *
     * @param \BeLenka\Deposco\Model\EntityRef|null $self self
     *
     * @return self
     */
    public function setSelf($self)
    {
        if (is_null($self)) {
            throw new \InvalidArgumentException('non-nullable self cannot be null');
        }
        $this->container['self'] = $self;

        return $this;
    }

    /**
     * Gets business_unit
     *
     * @return \BeLenka\Deposco\Model\EntityRef
     */
    public function getBusinessUnit()
    {
        return $this->container['business_unit'];
    }

    /**
     * Sets business_unit
     *
     * @param \BeLenka\Deposco\Model\EntityRef $business_unit business_unit
     *
     * @return self
     */
    public function setBusinessUnit($business_unit)
    {
        if (is_null($business_unit)) {
            throw new \InvalidArgumentException('non-nullable business_unit cannot be null');
        }
        $this->container['business_unit'] = $business_unit;

        return $this;
    }

    /**
     * Gets facility
     *
     * @return \BeLenka\Deposco\Model\EntityRef
     */
    public function getFacility()
    {
        return $this->container['facility'];
    }

    /**
     * Sets facility
     *
     * @param \BeLenka\Deposco\Model\EntityRef $facility facility
     *
     * @return self
     */
    public function setFacility($facility)
    {
        if (is_null($facility)) {
            throw new \InvalidArgumentException('non-nullable facility cannot be null');
        }
        $this->container['facility'] = $facility;

        return $this;
    }

    /**
     * Gets zones
     *
     * @return \BeLenka\Deposco\Model\PaginatedEntityReference|null
     */
    public function getZones()
    {
        return $this->container['zones'];
    }

    /**
     * Sets zones
     *
     * @param \BeLenka\Deposco\Model\PaginatedEntityReference|null $zones zones
     *
     * @return self
     */
    public function setZones($zones)
    {
        if (is_null($zones)) {
            array_push($this->openAPINullablesSetToNull, 'zones');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('zones', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['zones'] = $zones;

        return $this;
    }

    /**
     * Gets number
     *
     * @return string|null
     */
    public function getNumber()
    {
        return $this->container['number'];
    }

    /**
     * Sets number
     *
     * @param string|null $number Unique, descriptive code that identifies the location. For the Receiving and Shipping locations, include an abbreviated reference to the facility, such as LA-Receiving for the receiving location at the Los Angeles facility or CHI-Shipping for the shipping location at the Chicago facility. For other locations, include an abbreviated reference to the facility as well as other location identifiers such as the aisle, rack, and shelf. For example, NY-01AA03 might be the number for the third shelf on rack AA in aisle 01 in the New York facility.
     *
     * @return self
     */
    public function setNumber($number)
    {
        if (is_null($number)) {
            array_push($this->openAPINullablesSetToNull, 'number');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('number', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($number) && (mb_strlen($number) > 150)) {
            throw new \InvalidArgumentException('invalid length for $number when calling LocationDTO., must be smaller than or equal to 150.');
        }

        $this->container['number'] = $number;

        return $this;
    }

    /**
     * Gets locator
     *
     * @return string
     */
    public function getLocator()
    {
        return $this->container['locator'];
    }

    /**
     * Sets locator
     *
     * @param string $locator Unique identifier for the facility, typically represented as a barcode, that users can scan to confirm that picks and moves are occurring at the correct location within the facility. For the Receiving and Shipping locations, the locator is `Receiving` and `Shipping`, respectively.
     *
     * @return self
     */
    public function setLocator($locator)
    {
        if (is_null($locator)) {
            throw new \InvalidArgumentException('non-nullable locator cannot be null');
        }
        if ((mb_strlen($locator) > 150)) {
            throw new \InvalidArgumentException('invalid length for $locator when calling LocationDTO., must be smaller than or equal to 150.');
        }
        if ((!preg_match("/.*\\S.*/", ObjectSerializer::toString($locator)))) {
            throw new \InvalidArgumentException("invalid value for \$locator when calling LocationDTO., must conform to the pattern /.*\\S.*/.");
        }

        $this->container['locator'] = $locator;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name Name that identifies the location.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            array_push($this->openAPINullablesSetToNull, 'name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($name) && (mb_strlen($name) > 50)) {
            throw new \InvalidArgumentException('invalid length for $name when calling LocationDTO., must be smaller than or equal to 50.');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description Text that provides additional information about the location.
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            array_push($this->openAPINullablesSetToNull, 'description');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('description', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($description) && (mb_strlen($description) > 50)) {
            throw new \InvalidArgumentException('invalid length for $description when calling LocationDTO., must be smaller than or equal to 50.');
        }

        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type Type of location. Used for sorting, filtering, and reporting purposes.
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            array_push($this->openAPINullablesSetToNull, 'type');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('type', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($type) && !in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets storage_type
     *
     * @return string|null
     */
    public function getStorageType()
    {
        return $this->container['storage_type'];
    }

    /**
     * Sets storage_type
     *
     * @param string|null $storage_type Type of storage that the location is used for:  - `Staging` - Use this value for all shipping and receiving locations.  - `Split Case Picking` - Use this value to automatically convert stock units to the lowest unit of measure for the pack when stock is moved to this location.  - `Putwall Slot` and `Putwall Staging` - Use these values for locations associated with a put wall, which is used to sort picked orders before packing.  - The remaining values are informational only, and do not impact any workflow processes or other product functionality.
     *
     * @return self
     */
    public function setStorageType($storage_type)
    {
        if (is_null($storage_type)) {
            array_push($this->openAPINullablesSetToNull, 'storage_type');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('storage_type', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getStorageTypeAllowableValues();
        if (!is_null($storage_type) && !in_array($storage_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'storage_type', must be one of '%s'",
                    $storage_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['storage_type'] = $storage_type;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Current status of the location.
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            array_push($this->openAPINullablesSetToNull, 'status');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('status', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets dimensions
     *
     * @return \BeLenka\Deposco\Model\Dimension|null
     */
    public function getDimensions()
    {
        return $this->container['dimensions'];
    }

    /**
     * Sets dimensions
     *
     * @param \BeLenka\Deposco\Model\Dimension|null $dimensions dimensions
     *
     * @return self
     */
    public function setDimensions($dimensions)
    {
        if (is_null($dimensions)) {
            throw new \InvalidArgumentException('non-nullable dimensions cannot be null');
        }
        $this->container['dimensions'] = $dimensions;

        return $this;
    }

    /**
     * Gets pickable
     *
     * @return bool|null
     */
    public function getPickable()
    {
        return $this->container['pickable'];
    }

    /**
     * Sets pickable
     *
     * @param bool|null $pickable Whether the location is available to be picked from. When a pick wave is released, the wave includes pick tasks only for pickable locations.
     *
     * @return self
     */
    public function setPickable($pickable)
    {
        if (is_null($pickable)) {
            throw new \InvalidArgumentException('non-nullable pickable cannot be null');
        }
        $this->container['pickable'] = $pickable;

        return $this;
    }

    /**
     * Gets reserved
     *
     * @return bool|null
     */
    public function getReserved()
    {
        return $this->container['reserved'];
    }

    /**
     * Sets reserved
     *
     * @param bool|null $reserved Whether the location is used for reserve storage. The replenishment process validates that this field is set to `true` when determining whether you can replenish from a location.
     *
     * @return self
     */
    public function setReserved($reserved)
    {
        if (is_null($reserved)) {
            throw new \InvalidArgumentException('non-nullable reserved cannot be null');
        }
        $this->container['reserved'] = $reserved;

        return $this;
    }

    /**
     * Gets lpn_controlled
     *
     * @return bool|null
     */
    public function getLpnControlled()
    {
        return $this->container['lpn_controlled'];
    }

    /**
     * Sets lpn_controlled
     *
     * @param bool|null $lpn_controlled Whether the location includes LPNs that can be used to identify which stock unit to move, pick, or pack.
     *
     * @return self
     */
    public function setLpnControlled($lpn_controlled)
    {
        if (is_null($lpn_controlled)) {
            throw new \InvalidArgumentException('non-nullable lpn_controlled cannot be null');
        }
        $this->container['lpn_controlled'] = $lpn_controlled;

        return $this;
    }

    /**
     * Gets mixed_item_threshold
     *
     * @return string|null
     */
    public function getMixedItemThreshold()
    {
        return $this->container['mixed_item_threshold'];
    }

    /**
     * Sets mixed_item_threshold
     *
     * @param string|null $mixed_item_threshold Whether more than one item is stored in the location. Move processes validate this behavior and will either allow or prevent a user from putting a second item in the location.
     *
     * @return self
     */
    public function setMixedItemThreshold($mixed_item_threshold)
    {
        if (is_null($mixed_item_threshold)) {
            array_push($this->openAPINullablesSetToNull, 'mixed_item_threshold');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('mixed_item_threshold', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getMixedItemThresholdAllowableValues();
        if (!is_null($mixed_item_threshold) && !in_array($mixed_item_threshold, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'mixed_item_threshold', must be one of '%s'",
                    $mixed_item_threshold,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mixed_item_threshold'] = $mixed_item_threshold;

        return $this;
    }

    /**
     * Gets cycle_count
     *
     * @return bool|null
     */
    public function getCycleCount()
    {
        return $this->container['cycle_count'];
    }

    /**
     * Sets cycle_count
     *
     * @param bool|null $cycle_count Whether cycle counts should occur for the location.
     *
     * @return self
     */
    public function setCycleCount($cycle_count)
    {
        if (is_null($cycle_count)) {
            throw new \InvalidArgumentException('non-nullable cycle_count cannot be null');
        }
        $this->container['cycle_count'] = $cycle_count;

        return $this;
    }

    /**
     * Gets cycle_count_frequency
     *
     * @return int|null
     */
    public function getCycleCountFrequency()
    {
        return $this->container['cycle_count_frequency'];
    }

    /**
     * Sets cycle_count_frequency
     *
     * @param int|null $cycle_count_frequency Frequency in days at which cycle counts should occur for the location. This field is informational only, and does not impact any workflow processes or other product functionality.
     *
     * @return self
     */
    public function setCycleCountFrequency($cycle_count_frequency)
    {
        if (is_null($cycle_count_frequency)) {
            throw new \InvalidArgumentException('non-nullable cycle_count_frequency cannot be null');
        }
        $this->container['cycle_count_frequency'] = $cycle_count_frequency;

        return $this;
    }

    /**
     * Gets last_counted_date
     *
     * @return \DateTime|null
     */
    public function getLastCountedDate()
    {
        return $this->container['last_counted_date'];
    }

    /**
     * Sets last_counted_date
     *
     * @param \DateTime|null $last_counted_date Date on which either a cycle count or a physical count occurred for the location.
     *
     * @return self
     */
    public function setLastCountedDate($last_counted_date)
    {
        if (is_null($last_counted_date)) {
            array_push($this->openAPINullablesSetToNull, 'last_counted_date');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('last_counted_date', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['last_counted_date'] = $last_counted_date;

        return $this;
    }

    /**
     * Gets pick_sequence
     *
     * @return int|null
     */
    public function getPickSequence()
    {
        return $this->container['pick_sequence'];
    }

    /**
     * Sets pick_sequence
     *
     * @param int|null $pick_sequence Numeric value that indicates the order in which the location should be picked from in relation to other locations.
     *
     * @return self
     */
    public function setPickSequence($pick_sequence)
    {
        if (is_null($pick_sequence)) {
            throw new \InvalidArgumentException('non-nullable pick_sequence cannot be null');
        }
        $this->container['pick_sequence'] = $pick_sequence;

        return $this;
    }

    /**
     * Gets putaway_sequence
     *
     * @return int|null
     */
    public function getPutawaySequence()
    {
        return $this->container['putaway_sequence'];
    }

    /**
     * Sets putaway_sequence
     *
     * @param int|null $putaway_sequence Numeric value that indicates the order in which stock should be put away after receiving or during replenishment in relation to other locations.
     *
     * @return self
     */
    public function setPutawaySequence($putaway_sequence)
    {
        if (is_null($putaway_sequence)) {
            throw new \InvalidArgumentException('non-nullable putaway_sequence cannot be null');
        }
        $this->container['putaway_sequence'] = $putaway_sequence;

        return $this;
    }

    /**
     * Gets use_for_kit
     *
     * @return bool|null
     */
    public function getUseForKit()
    {
        return $this->container['use_for_kit'];
    }

    /**
     * Sets use_for_kit
     *
     * @param bool|null $use_for_kit Whether the location is used for assembling the component items for a bundled product. This option is informational only, and does not impact any workflow processes or other product functionality.
     *
     * @return self
     */
    public function setUseForKit($use_for_kit)
    {
        if (is_null($use_for_kit)) {
            throw new \InvalidArgumentException('non-nullable use_for_kit cannot be null');
        }
        $this->container['use_for_kit'] = $use_for_kit;

        return $this;
    }

    /**
     * Gets allocated_to_business_unit
     *
     * @return \BeLenka\Deposco\Model\NullableEntityRef|null
     */
    public function getAllocatedToBusinessUnit()
    {
        return $this->container['allocated_to_business_unit'];
    }

    /**
     * Sets allocated_to_business_unit
     *
     * @param \BeLenka\Deposco\Model\NullableEntityRef|null $allocated_to_business_unit allocated_to_business_unit
     *
     * @return self
     */
    public function setAllocatedToBusinessUnit($allocated_to_business_unit)
    {
        if (is_null($allocated_to_business_unit)) {
            array_push($this->openAPINullablesSetToNull, 'allocated_to_business_unit');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('allocated_to_business_unit', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['allocated_to_business_unit'] = $allocated_to_business_unit;

        return $this;
    }

    /**
     * Gets custom_attribute1
     *
     * @return string|null
     */
    public function getCustomAttribute1()
    {
        return $this->container['custom_attribute1'];
    }

    /**
     * Sets custom_attribute1
     *
     * @param string|null $custom_attribute1 Custom field for the location.
     *
     * @return self
     */
    public function setCustomAttribute1($custom_attribute1)
    {
        if (is_null($custom_attribute1)) {
            array_push($this->openAPINullablesSetToNull, 'custom_attribute1');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('custom_attribute1', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($custom_attribute1) && (mb_strlen($custom_attribute1) > 50)) {
            throw new \InvalidArgumentException('invalid length for $custom_attribute1 when calling LocationDTO., must be smaller than or equal to 50.');
        }

        $this->container['custom_attribute1'] = $custom_attribute1;

        return $this;
    }

    /**
     * Gets custom_attribute2
     *
     * @return string|null
     */
    public function getCustomAttribute2()
    {
        return $this->container['custom_attribute2'];
    }

    /**
     * Sets custom_attribute2
     *
     * @param string|null $custom_attribute2 Custom field for the location.
     *
     * @return self
     */
    public function setCustomAttribute2($custom_attribute2)
    {
        if (is_null($custom_attribute2)) {
            array_push($this->openAPINullablesSetToNull, 'custom_attribute2');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('custom_attribute2', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($custom_attribute2) && (mb_strlen($custom_attribute2) > 50)) {
            throw new \InvalidArgumentException('invalid length for $custom_attribute2 when calling LocationDTO., must be smaller than or equal to 50.');
        }

        $this->container['custom_attribute2'] = $custom_attribute2;

        return $this;
    }

    /**
     * Gets custom_attribute3
     *
     * @return string|null
     */
    public function getCustomAttribute3()
    {
        return $this->container['custom_attribute3'];
    }

    /**
     * Sets custom_attribute3
     *
     * @param string|null $custom_attribute3 Custom field for the location.
     *
     * @return self
     */
    public function setCustomAttribute3($custom_attribute3)
    {
        if (is_null($custom_attribute3)) {
            array_push($this->openAPINullablesSetToNull, 'custom_attribute3');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('custom_attribute3', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($custom_attribute3) && (mb_strlen($custom_attribute3) > 50)) {
            throw new \InvalidArgumentException('invalid length for $custom_attribute3 when calling LocationDTO., must be smaller than or equal to 50.');
        }

        $this->container['custom_attribute3'] = $custom_attribute3;

        return $this;
    }

    /**
     * Gets storage_details
     *
     * @return \BeLenka\Deposco\Model\StorageCollectionDTO|null
     */
    public function getStorageDetails()
    {
        return $this->container['storage_details'];
    }

    /**
     * Sets storage_details
     *
     * @param \BeLenka\Deposco\Model\StorageCollectionDTO|null $storage_details storage_details
     *
     * @return self
     */
    public function setStorageDetails($storage_details)
    {
        if (is_null($storage_details)) {
            throw new \InvalidArgumentException('non-nullable storage_details cannot be null');
        }
        $this->container['storage_details'] = $storage_details;

        return $this;
    }

    /**
     * Gets created_date
     *
     * @return \DateTime|null
     */
    public function getCreatedDate()
    {
        return $this->container['created_date'];
    }

    /**
     * Sets created_date
     *
     * @param \DateTime|null $created_date Date and time that the location was created.
     *
     * @return self
     */
    public function setCreatedDate($created_date)
    {
        if (is_null($created_date)) {
            throw new \InvalidArgumentException('non-nullable created_date cannot be null');
        }
        $this->container['created_date'] = $created_date;

        return $this;
    }

    /**
     * Gets updated_date
     *
     * @return \DateTime|null
     */
    public function getUpdatedDate()
    {
        return $this->container['updated_date'];
    }

    /**
     * Sets updated_date
     *
     * @param \DateTime|null $updated_date Date and time that the location was last updated.
     *
     * @return self
     */
    public function setUpdatedDate($updated_date)
    {
        if (is_null($updated_date)) {
            throw new \InvalidArgumentException('non-nullable updated_date cannot be null');
        }
        $this->container['updated_date'] = $updated_date;

        return $this;
    }

    /**
     * Gets created_by
     *
     * @return \BeLenka\Deposco\Model\EntityRef|null
     */
    public function getCreatedBy()
    {
        return $this->container['created_by'];
    }

    /**
     * Sets created_by
     *
     * @param \BeLenka\Deposco\Model\EntityRef|null $created_by created_by
     *
     * @return self
     */
    public function setCreatedBy($created_by)
    {
        if (is_null($created_by)) {
            throw new \InvalidArgumentException('non-nullable created_by cannot be null');
        }
        $this->container['created_by'] = $created_by;

        return $this;
    }

    /**
     * Gets updated_by
     *
     * @return \BeLenka\Deposco\Model\EntityRef|null
     */
    public function getUpdatedBy()
    {
        return $this->container['updated_by'];
    }

    /**
     * Sets updated_by
     *
     * @param \BeLenka\Deposco\Model\EntityRef|null $updated_by updated_by
     *
     * @return self
     */
    public function setUpdatedBy($updated_by)
    {
        if (is_null($updated_by)) {
            throw new \InvalidArgumentException('non-nullable updated_by cannot be null');
        }
        $this->container['updated_by'] = $updated_by;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


